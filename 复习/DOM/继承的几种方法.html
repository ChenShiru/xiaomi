<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    /*原型继承*/
/*
function A() {
　　this.x = 100;
}
A.prototype.getX = function () {
　　console.log(this.x);
};
function B() {
this.test="test"
}
B.prototype.getY = function () {
　　console.log("B.prototype");
};
B.prototype = new A;
var b = new B;
console.dir(b);
b.x=200;
b.getX();//200;
A.prototype.getX();//undefined
//子类重写父类的方法
b.__proto__.__proto__.getX = function () {
console.log(this.x + 1000);
};
b.getX();//1200;
*/


    /*call继承*/


  /* function A(){
       this.x =10;
       this.flag = "flagA";
   }
    A.prototype.getX=function(){
            console.log(this.x);
    };
    function B(){
        A.call(this);
        this.flag = "flagB";
    }
    B.prototype.getX = function(){
        console.log(this.x);
    };
    var b = new B();
    console.log(b);*/


    /*function A(){
        this.color = ['red','green'];
    }
    function B(){
        A.call(this);
    }
    var b1 = new B();
    b1.color.push('black');
    console.log(b1.color);
    var b2  = new B();
    console.log(b2.color);*/


/* call继承加原型继承*/
    /*function A() {
        this.x = 100;
        this.flagA="flagA"
    }
    A.prototype.getX = function () {
        console.log(this.x);
    };
    function B() {
        A.call(this);
        this.flagB="flagB"
    }
    B.prototype.getBPrototype = function () {
        console.log("B.prototype");
    };


    B.prototype = new A;
    var b = new B;

    console.log(b);*/




    function SuperType(name){
        this.name = name;
        this.colors = ["red", "blue", "green"];
    }
    SuperType.prototype.sayName = function(){
        console.log(this.name);
    };
    function SubType(name, age){
        //继承属性
        SuperType.call(this, name);
        this.age = age;
    }
    //继承方法
    /*SubType.prototype = new SuperType();
    SubType.prototype.constructor = SubType;//constructor 需要写回去，否则SubType虽然继承了SuperType的私有属性和公有属性，但是SubType原来的原型被重写了；
    SubType.prototype.sayAge = function(){
        console.log(this.age);
    };
    var instance1 = new SubType("Nicholas", 29);
    instance1.colors.push("black");
    console.log(instance1.colors); //"red,blue,green,black"
    instance1.sayName(); //"Nicholas";
    instance1.sayAge(); //29

    var instance2 = new SubType("Greg", 27);
    console.log(instance2.colors); //"red,blue,green"
    instance2.sayName(); //"Greg";
    instance2.sayAge(); //27*/


    /*冒充对象继承*/
    function A() {
        this.x = 100;
        this.flagA="flagA"
    }
    A.prototype.getX = function () {
        console.log(this.x);
    };
    function B() {
        // A.call(this);
        this.flagB="flagB";

        var temp = new A;//->temp中现在就存有了A中的私有和公有的属性/方法
        for (var key in temp) {
            this[key] = temp[key];
        }
        temp = null;
    }
    B.prototype.getBPrototype = function () {
        console.log("B.prototype");
    };

    var b = new B;
    console.log(b);
</script>
</body>
</html>